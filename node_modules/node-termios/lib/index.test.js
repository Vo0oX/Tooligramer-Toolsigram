"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var _1 = require(".");
var pty = require("node-pty");
var os_1 = require("os");
/**
 * Note: Tests need stdin (0) to be a real TTY.
 */
describe('native functions', function () {
    describe('isatty', function () {
        it('true on stdin', function () {
            chai_1.assert.equal(_1.native.isatty(0), true);
        });
        it('false on non tty fd', function () {
            var fs = require('fs');
            var fd = fs.openSync('/', 'r');
            chai_1.assert.equal(_1.native.isatty(fd), false);
            fs.closeSync(fd);
        });
        it('should throw for illegal fd (except on solaris)', function () {
            if (os_1.platform() === 'sunos') {
                chai_1.assert.equal(_1.native.isatty(12345), false);
            }
            else {
                chai_1.assert.throws(function () { return _1.native.isatty(12345); });
            }
        });
    });
    describe('ttyname', function () {
        it('should return path string on tty fd', function () {
            chai_1.assert.notEqual(_1.native.ttyname(0), '');
        });
        it('should return empty string on non tty fd', function () {
            var fs = require('fs');
            var fd = fs.openSync('/', 'r');
            chai_1.assert.equal(_1.native.ttyname(fd), '');
            fs.closeSync(fd);
        });
    });
    describe('ptsname', function () {
        it('should return path string on pty master fd', function (done) {
            var p = pty.spawn('sh', [], {});
            var path = _1.native.ptsname(p._fd);
            chai_1.assert.notEqual(path, '');
            var fromPty = [];
            p.onData(function (data) { return fromPty.push(data); });
            p.write('tty\r'); // report ttyname from slave end
            setTimeout(function () {
                p.kill();
                // ttyname on slave should return ptsname on master
                chai_1.assert.equal(fromPty.join('').includes(path), true);
                done();
            }, 100);
        });
        it('should return empty string on non pty master fd', function () {
            var fs = require('fs');
            var fd = fs.openSync('/', 'r');
            chai_1.assert.equal(_1.native.ptsname(fd), '');
            fs.closeSync(fd);
            chai_1.assert.equal(_1.native.ptsname(0), '');
        });
    });
    describe('tcgetattr', function () {
        it('should load data into buffer', function () {
            var buf = Buffer.from(Array(_1.native.EXPLAIN.size));
            _1.native.tcgetattr(0, buf);
            chai_1.assert.notDeepEqual(buf, Buffer.from(Array(_1.native.EXPLAIN.size)));
        });
        it('should reject wrong arguments', function () {
            // illegal fd
            chai_1.assert.throws(function () { return _1.native.tcgetattr(-1, Buffer.from(Array(_1.native.EXPLAIN.size))); });
            var fs = require('fs');
            var fd = fs.openSync('/', 'r');
            chai_1.assert.throws(function () { return _1.native.tcgetattr(fd, Buffer.from(Array(_1.native.EXPLAIN.size))); });
            fs.closeSync(fd);
            // misaligned buffer
            chai_1.assert.throws(function () { return _1.native.tcgetattr(0, Buffer.from(Array(10))); }, 'wrong buffer type');
        });
    });
    describe('tcsetattr', function () {
        var oldAttrs;
        beforeEach(function () {
            oldAttrs = Buffer.from(Array(_1.native.EXPLAIN.size));
            _1.native.tcgetattr(0, oldAttrs);
        });
        afterEach(function () {
            _1.native.tcsetattr(0, _1.native.ACTION.TCSANOW, oldAttrs);
        });
        it('read/write/read test', function () {
            // not all values are nullable, we test only for iflag and oflag
            var attr = Buffer.from(Array(_1.native.EXPLAIN.size));
            _1.native.tcgetattr(0, attr);
            attr.subarray(0, 8).fill(0); // --> spans iflag and oflag byte range
            _1.native.tcsetattr(0, _1.native.ACTION.TCSANOW, attr);
            var attrRead = Buffer.from(Array(_1.native.EXPLAIN.size));
            _1.native.tcgetattr(0, attrRead);
            chai_1.assert.deepEqual(attrRead, attr);
            _1.native.tcsetattr(0, _1.native.ACTION.TCSANOW, oldAttrs);
        });
        it('should reject wrong arguments', function () {
            // illegal fd
            chai_1.assert.throws(function () { return _1.native.tcsetattr(-1, _1.native.ACTION.TCSANOW, Buffer.from(Array(_1.native.EXPLAIN.size))); });
            var fs = require('fs');
            var fd = fs.openSync('/', 'r');
            chai_1.assert.throws(function () { return _1.native.tcsetattr(fd, _1.native.ACTION.TCSANOW, Buffer.from(Array(_1.native.EXPLAIN.size))); });
            fs.closeSync(fd);
            // misaligned buffer
            chai_1.assert.throws(function () { return _1.native.tcsetattr(0, _1.native.ACTION.TCSANOW, Buffer.from(Array(10))); }, 'wrong buffer type');
        });
    });
    /**
     * Note tested:
     *    tcsendbreak, tcdrain, tcflush, tcflow
     */
});
describe('Termios', function () {
    it('ctor from valid tty fd', function () {
        var t = new _1.Termios(0);
        chai_1.assert.notEqual(t.c_iflag, 0);
        chai_1.assert.notEqual(t.c_oflag, 0);
        chai_1.assert.notEqual(t.c_cflag, 0);
        chai_1.assert.notEqual(t.c_lflag, 0);
    });
    it('ctor from other Termios object', function () {
        var t1 = new _1.Termios(0);
        var t2 = new _1.Termios(t1);
        chai_1.assert.equal(t2.c_iflag, t1.c_iflag);
        chai_1.assert.equal(t2.c_oflag, t1.c_oflag);
        chai_1.assert.equal(t2.c_cflag, t1.c_cflag);
        chai_1.assert.equal(t2.c_lflag, t1.c_lflag);
        chai_1.assert.deepEqual(t2.c_cc, t1.c_cc);
        chai_1.assert.deepEqual(t2._data, t1._data);
    });
    it('ctor from explicit null should create empty', function () {
        var t = new _1.Termios(null);
        chai_1.assert.equal(t.c_iflag, 0);
        chai_1.assert.equal(t.c_oflag, 0);
        chai_1.assert.equal(t.c_cflag, 0);
        chai_1.assert.equal(t.c_lflag, 0);
        chai_1.assert.deepEqual(t.c_cc, Buffer.from(Array(_1.native.EXPLAIN.members.c_cc.width)));
        chai_1.assert.deepEqual(t._data, Buffer.from(Array(_1.native.EXPLAIN.size)));
    });
    it('ctor from undefined should pull ttydefaults.h', function () {
        // Note - ttydefaults.h not supported on solaris
        var UNSUPPORTED = ['sunos', 'aix'];
        var t = new _1.Termios();
        if (UNSUPPORTED.indexOf(os_1.platform()) !== -1) {
            chai_1.assert.equal(t.c_iflag, 0);
            chai_1.assert.equal(t.c_oflag, 0);
            chai_1.assert.equal(t.c_cflag, 0);
            chai_1.assert.equal(t.c_lflag, 0);
            chai_1.assert.deepEqual(t.c_cc, Buffer.from(Array(_1.native.EXPLAIN.members.c_cc.width)));
        }
        else {
            chai_1.assert.notEqual(t.c_iflag, 0);
            chai_1.assert.notEqual(t.c_oflag, 0);
            chai_1.assert.notEqual(t.c_cflag, 0);
            chai_1.assert.notEqual(t.c_lflag, 0);
            // test typical default control codes from ttydefaults.h
            var ctrl = function (c) { return c.charCodeAt(0) & 31; };
            chai_1.assert.equal(t.c_cc[_1.native.CC.VEOF], ctrl('d'));
            chai_1.assert.equal(t.c_cc[_1.native.CC.VINTR], ctrl('c'));
            chai_1.assert.equal(t.c_cc[_1.native.CC.VSTART], ctrl('q'));
            chai_1.assert.equal(t.c_cc[_1.native.CC.VSTOP], ctrl('s'));
            chai_1.assert.equal(t.c_cc[_1.native.CC.VSUSP], ctrl('z'));
            chai_1.assert.equal(t.c_cc[_1.native.CC.VREPRINT], ctrl('r'));
        }
    });
    it('ctor rejects invalid arguments', function () {
        // invalid fd
        chai_1.assert.throws(function () { return new _1.Termios(-1); });
        chai_1.assert.throws(function () { return new _1.Termios(12345); });
    });
    it('flags getter/setter', function () {
        var t = new _1.Termios(0);
        // these assumptions are abit flakey and might fail on some CIs
        chai_1.assert.notEqual(t.c_iflag, 0);
        chai_1.assert.notEqual(t.c_oflag, 0);
        chai_1.assert.notEqual(t.c_lflag, 0);
        // toggle settings
        t.c_iflag &= ~(_1.native.IFLAGS.BRKINT | _1.native.IFLAGS.ICRNL);
        chai_1.assert.equal(t.c_iflag & _1.native.IFLAGS.BRKINT, 0);
        chai_1.assert.equal(t.c_iflag & _1.native.IFLAGS.ICRNL, 0);
        t.c_iflag |= _1.native.IFLAGS.BRKINT | _1.native.IFLAGS.ICRNL;
        chai_1.assert.notEqual(t.c_iflag & _1.native.IFLAGS.BRKINT, 0);
        chai_1.assert.notEqual(t.c_iflag & _1.native.IFLAGS.ICRNL, 0);
        t.c_oflag &= ~(_1.native.OFLAGS.OPOST | _1.native.OFLAGS.ONLCR);
        chai_1.assert.equal(t.c_oflag & _1.native.OFLAGS.OPOST, 0);
        chai_1.assert.equal(t.c_oflag & _1.native.OFLAGS.ONLCR, 0);
        t.c_oflag |= _1.native.OFLAGS.OPOST | _1.native.OFLAGS.ONLCR;
        chai_1.assert.notEqual(t.c_oflag & _1.native.OFLAGS.OPOST, 0);
        chai_1.assert.notEqual(t.c_oflag & _1.native.OFLAGS.ONLCR, 0);
        t.c_lflag &= ~(_1.native.LFLAGS.ECHO | _1.native.LFLAGS.ICANON);
        chai_1.assert.equal(t.c_lflag & _1.native.LFLAGS.ECHO, 0);
        chai_1.assert.equal(t.c_lflag & _1.native.LFLAGS.ICANON, 0);
        t.c_lflag |= _1.native.LFLAGS.ECHO | _1.native.LFLAGS.ICANON;
        chai_1.assert.notEqual(t.c_lflag & _1.native.LFLAGS.ECHO, 0);
        chai_1.assert.notEqual(t.c_lflag & _1.native.LFLAGS.ICANON, 0);
    });
    it('speed methods', function () {
        // note that nowadays both speeds are normally entangled,
        // thus setting one also applies to the other one
        var t = new _1.Termios(0);
        var iSpeed = t.getInputSpeed();
        chai_1.assert.notEqual(iSpeed, _1.native.BAUD.B75);
        var oSpeed = t.getOutputSpeed();
        chai_1.assert.notEqual(oSpeed, _1.native.BAUD.B75);
        t.setInputSpeed(_1.native.BAUD.B75);
        chai_1.assert.equal(t.getInputSpeed(), _1.native.BAUD.B75);
        t.setOutputSpeed(_1.native.BAUD.B75);
        chai_1.assert.equal(t.getOutputSpeed(), _1.native.BAUD.B75);
    });
});
describe('terminal write/read test', function () {
    // cannot be tested on solaris (pty master does not support termios semantics)
    if (os_1.platform() === 'sunos')
        return;
    it('disable ECHO', function (done) {
        var p = pty.spawn('cat', [], {});
        var t = new _1.Termios(p._fd);
        var fromPty = [];
        p.onData(function (data) {
            fromPty.push(data);
            if (data.includes('#again_readable#')) {
                p.kill();
                chai_1.assert.equal(fromPty.join('').includes('#readable##again_readable#'), true);
                done();
            }
        });
        p.write('#readable#');
        setTimeout(function () {
            // this must not show up on the terminal
            t.c_lflag &= ~_1.native.LFLAGS.ECHO;
            t.writeTo(p._fd, _1.native.ACTION.TCSADRAIN);
            p.write('*TOP_SECRET*');
        }, 50);
        setTimeout(function () {
            t.c_lflag |= _1.native.LFLAGS.ECHO;
            t.writeTo(p._fd, _1.native.ACTION.TCSADRAIN);
            p.write('#again_readable#');
        }, 100);
    });
});
describe('worker support', function () {
    it('multiple workers calling into native code', function (done) {
        var Worker = require('worker_threads').Worker;
        var AMOUNT = 5;
        var workers = [];
        var messages = [];
        for (var i = 0; i < AMOUNT; ++i) {
            var worker = new Worker("\n        const { Termios } = require('.');\n        const { parentPort } = require('worker_threads');\n        parentPort.once('message', msg => parentPort.postMessage(JSON.stringify(new Termios(0))));", { eval: true });
            worker.once('message', function (msg) {
                messages.push(msg);
                if (messages.length === AMOUNT) {
                    // all should be equal
                    var first = messages[0];
                    for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
                        msg = messages_1[_i];
                        chai_1.assert.equal(msg, first);
                    }
                    done();
                }
            });
            workers.push(worker);
        }
        // trigger `new Termios(0)` on all workers
        workers.forEach(function (w) { return w.postMessage('ready'); });
    });
});
//# sourceMappingURL=index.test.js.map