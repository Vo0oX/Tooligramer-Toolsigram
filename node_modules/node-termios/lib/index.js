"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
if (process.platform === 'win32')
    throw new Error('unsupported platform');
var path = require("path");
var os_1 = require("os");
exports.native = require(path.join('..', 'build', 'Release', 'termios.node'));
var s = exports.native.ALL_SYMBOLS;
var ENDIAN = os_1.endianness();
/**
 * EXPLAIN holds the termios structure memory layout from C,
 * so we know how to access struct members.
 *
 * We have to explicitly test the type widths, since they are not fixed typed.
 * Still `tcflag_t`, typed as `unsigned int` on most platforms (except OSX),
 * translates to a 4 byte endian-aware read/write at offset.
 * We ignore the type being 2 bytes on older platforms, as they are not relevant.
 *
 * OSX/Darwin switched to a `unsigned long long` type (8 bytes), but only uses the
 * lower 32 bits. Thus we can treat it as 4 byte at offset on LE. BE would need
 * an offset shift by 4 bytes (currently not implemented).
 * Once they decide to use higher bits, we have to rework the whole symbol export
 * to use BigInt.
 * On C side the macro _SAFE32_ ensures, that a wider symbol does not lose bits by accident.
 *
 * Tested on: Linux 5, OSX Mojave, FreeBSD 11, OpenIndiana 2019.
 */
var EXPLAIN = exports.native.EXPLAIN;
var T_SIZE = EXPLAIN.size;
var T_MEM = EXPLAIN.members;
// monkey patch width to 4 on darwin LE to pass the tests below
if (os_1.platform() === 'darwin' && ENDIAN === 'LE') {
    T_MEM.c_iflag.width = 4;
    T_MEM.c_oflag.width = 4;
    T_MEM.c_cflag.width = 4;
    T_MEM.c_lflag.width = 4;
}
// refuse any platform, that does not hold flags in 4 bytes / control codes in 1 byte
if (T_MEM.c_iflag.width !== 4)
    throw new Error('unexpected c_iflag type');
if (T_MEM.c_oflag.width !== 4)
    throw new Error('unexpected c_oflag type');
if (T_MEM.c_cflag.width !== 4)
    throw new Error('unexpected c_cflag type');
if (T_MEM.c_lflag.width !== 4)
    throw new Error('unexpected c_lflag type');
if (T_MEM.c_cc.elem_size !== 1)
    throw new Error('unexpected cc_t type');
/**
 * Handle buffer data access.
 * We currently only support BE/LE with 4 bytes.
 */
var ACCESSORS = {
    BE: {
        4: {
            read: function (b, offset) { return b.readUInt32BE(offset); },
            write: function (b, value, offset) { return b.writeUInt32BE(value, offset); }
        }
    },
    LE: {
        4: {
            read: function (b, offset) { return b.readUInt32LE(offset); },
            write: function (b, value, offset) { return b.writeUInt32LE(value, offset); }
        }
    }
};
/**
 * Class holding `struct termios` data.
 */
var Termios = /** @class */ (function () {
    /**
     * Create new termios object.
     *
     * `from` can be a valid file descriptor (number),
     * another `Termios` object (copy constructor) or `null` (all data zeroed out).
     * Omitting `from` will try to load default values from *ttydefaults.h*
     * (not supported by all platforms).
     *
     * @param from Optional argument to pull termios settings from.
     */
    function Termios(from) {
        this._data = Buffer.from(Array(T_SIZE));
        // compatibility with old behavior
        // FIXME: remove once we switch to ES6 target
        if (!(this instanceof Termios)) {
            return new Termios(from);
        }
        if (typeof from === 'number') {
            this.loadFrom(from);
        }
        else if (from instanceof Termios) {
            this._data = Buffer.from(from._data);
        }
        else if (from === undefined) {
            if (!exports.native.load_ttydefaults(this._data)) {
                console.warn('Termios: Loading ttydefaults.h not supported on this platform.');
            }
        }
        else if (from !== null) {
            // null explicitly loads empty termios data
            // anything else throws an error
            throw new Error('unsupported from value');
        }
        // make termios primitives enumerable
        for (var _i = 0, _a = ['c_iflag', 'c_oflag', 'c_cflag', 'c_lflag', 'c_cc']; _i < _a.length; _i++) {
            var property = _a[_i];
            var desc = Object.getOwnPropertyDescriptor(Termios.prototype, property);
            var modified = Object.assign(desc, { enumerable: true });
            Object.defineProperty(this, property, modified);
        }
    }
    Object.defineProperty(Termios.prototype, "c_iflag", {
        /** Getter/setter for input flags. */
        get: function () {
            return ACCESSORS[ENDIAN][4].read(this._data, T_MEM.c_iflag.offset);
        },
        set: function (value) {
            ACCESSORS[ENDIAN][4].write(this._data, value, T_MEM.c_iflag.offset);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Termios.prototype, "c_oflag", {
        /** Getter/setter for output flags. */
        get: function () {
            return ACCESSORS[ENDIAN][4].read(this._data, T_MEM.c_oflag.offset);
        },
        set: function (value) {
            ACCESSORS[ENDIAN][4].write(this._data, value, T_MEM.c_oflag.offset);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Termios.prototype, "c_cflag", {
        /** Getter/setter for control flags. */
        get: function () {
            return ACCESSORS[ENDIAN][4].read(this._data, T_MEM.c_cflag.offset);
        },
        set: function (value) {
            ACCESSORS[ENDIAN][4].write(this._data, value, T_MEM.c_cflag.offset);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Termios.prototype, "c_lflag", {
        /** Getter/setter for local flags. */
        get: function () {
            return ACCESSORS[ENDIAN][4].read(this._data, T_MEM.c_lflag.offset);
        },
        set: function (value) {
            ACCESSORS[ENDIAN][4].write(this._data, value, T_MEM.c_lflag.offset);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Termios.prototype, "c_cc", {
        /** Buffer to access control code settings. */
        get: function () {
            return this._data.subarray(T_MEM.c_cc.offset, T_MEM.c_cc.offset + T_MEM.c_cc.width);
        },
        enumerable: true,
        configurable: true
    });
    /** Load termios data from file descriptor `fd`. */
    Termios.prototype.loadFrom = function (fd) {
        exports.native.tcgetattr(fd, this._data);
    };
    /**
     * Write termios data to file descriptor `fd`.
     *
     * `action` should be one of `native.ACTION`
     * (default: `TCSAFLUSH`).
     */
    Termios.prototype.writeTo = function (fd, action) {
        if (action === void 0) { action = s.TCSAFLUSH; }
        exports.native.tcsetattr(fd, action, this._data);
    };
    /** Return input channel baud rate setting as in `native.BAUD`. */
    Termios.prototype.getInputSpeed = function () {
        return exports.native.cfgetispeed(this._data);
    };
    /** Return output channel baud rate setting as in `native.BAUD`. */
    Termios.prototype.getOutputSpeed = function () {
        return exports.native.cfgetospeed(this._data);
    };
    /**
     * Set input channel baud rate.
     *
     * `speed` should be one of the baudrates in `native.BAUD`.
     */
    Termios.prototype.setInputSpeed = function (speed) {
        exports.native.cfsetispeed(this._data, speed);
    };
    /**
     * Set output channel baud rate.
     *
     * `speed` should be one of the baudrates in `native.BAUD`.
     */
    Termios.prototype.setOutputSpeed = function (speed) {
        exports.native.cfsetospeed(this._data, speed);
    };
    /**
     * Set input and output channel baud rate.
     *
     * `speed` should be one of the baudrates in `native.BAUD`.
     * @note Normally the input and output speed are entangled by the system,
     * thus setting one would also change the other one.
     */
    Termios.prototype.setSpeed = function (speed) {
        exports.native.cfsetispeed(this._data, speed);
        exports.native.cfsetospeed(this._data, speed);
    };
    /** Convenient method to set termios data to raw mode (flags taken from Python). */
    Termios.prototype.setraw = function () {
        this.c_iflag &= ~(s.BRKINT | s.ICRNL | s.INPCK | s.ISTRIP | s.IXON);
        this.c_oflag &= ~s.OPOST;
        this.c_cflag &= ~(s.CSIZE | s.PARENB);
        this.c_cflag |= s.CS8;
        this.c_lflag &= ~(s.ECHO | s.ICANON | s.IEXTEN | s.ISIG);
        this.c_cc[s.VMIN] = 1;
        this.c_cc[s.VTIME] = 0;
    };
    /** Convenient method to set termios data to cbreak mode (flags taken from Python). */
    Termios.prototype.setcbreak = function () {
        this.c_lflag &= ~(s.ECHO | s.ICANON);
        this.c_cc[s.VMIN] = 1;
        this.c_cc[s.VTIME] = 0;
    };
    /**
     * Convenient method to set termios data back to cooked mode.
     *
     * @note This method enables typical flags of cooked mode,
     * like job control (BRKINT), NL/CR rewrites and the line editor
     * (ICANON) with echoing (ECHO). This might differ from your
     * expectations, as systems may use slightly different settings.
     */
    Termios.prototype.setcooked = function () {
        this.c_iflag = s.BRKINT | s.ICRNL | s.INPCK | s.ISTRIP | s.IXON | s.IGNPAR;
        this.c_oflag = s.OPOST | s.ONLCR;
        this.c_cflag |= s.CS8;
        this.c_lflag = s.ECHOKE | s.ECHOCTL | s.ECHOE | s.ECHO | s.ICANON | s.IEXTEN | s.ISIG;
        if (s.ECHOK) {
            this.c_lflag |= s.ECHOK;
        }
        // FIXME: set c_cc values?
    };
    return Termios;
}());
exports.Termios = Termios;
//# sourceMappingURL=index.js.map